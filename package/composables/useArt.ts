/**
 * This module relies heavily on seeds and hashes to generate shapes. A seed is a string that is
 * used to deterministically generate a hash. A hash is a number representation of the seed
 * and it is used, along with its digits, to deterministically generate the dimensions of a shape.
 */

import P5 from 'p5';
import { ref, type Ref } from 'vue';
import { useColor, useCrypto } from './index';

/**
 * Canvas that will be drawn on
 */
interface Canvas {
	width: number;
	height: number;
}

/**
 * Shape that will be drawn on the canvas
 */
interface Shape {
	x: number;
	y: number;
	width: number;
	height: number;
	color: string;
}

/**
 * Configurations for the artist composable
 */
interface ArtistConfig {
  /**
   * Used to generate shapes in a deterministic way
   */
  seed?: string;
  /**
   * Number of shapes to draw
   */
  shapeNumber?: number;
  /**
   * Function that draws a shapes
   */
  shapeGenerator: (seed: string, canvas: Canvas, prevShape?: Shape) => Shape;
}

/**
 * Returns the last digit of a number. (e.g. If the number is a double, then the last digit
 * of the decimal is returned. If the last digit is 0, then the next digit to the left is 
 * returned. )
 */
function _getLastDigit(num: number): number {
  const numStr = num + '';
  
  // get last digit of number
  let lastDigit: number = parseInt(numStr[numStr.length - 1]);

  while(lastDigit === 0) {
    // get next digit to the left
    lastDigit = parseInt(numStr[numStr.length - 2]);
  }

  return lastDigit;
}

/**
* Returns a list of deterministic sub-seeds from the original seed. (e.g. if original hash is
* 0.123456789 and shapeNumber is 3, then each shape will be generated by using 3 digits from 
* the original hash and starting from left to right such that: `shapeHashes = [123, 456, 789]` )
* 
* @param seed - original seed
* @param subSeedNum - number of sub-seeds to generate
* @param digitsPerShape - number of digits to use from the original seed to generate each sub-seed
*/
function _getSubSeeds(seed: string, subSeedNum: number, digitsPerShape: number): string[] {
  
  const seeds: string[] = [];
          
  let index = 0;

  while(seeds.length < subSeedNum) {
    let extraction: string;
    
    // index has reached the end of the seed, so start over
    // and increment the `digitsPerShape` to get more randomness
    if(index >= seed.length) {
      index = 0;
      digitsPerShape ++;
    }

    // index is about to go out of bounds, so break the 
    // seed-to-extact into two parts
    if(index + digitsPerShape > seed.length) {
      const diff = (index + digitsPerShape) - seed.length;
      const first = seed.slice(index, seed.length);
      const second = seed.slice(0, diff);

      extraction = `${first}${second}`;

      index = diff;
      digitsPerShape ++;
    }

    else {
      extraction = seed.slice(index, index + digitsPerShape);
      index += digitsPerShape;
    }

    seeds.push(extraction)
  }

  return seeds;
}

/**
* Returns a coordinate that is positive and less than 1 based on a hash that is positive and less 
* than 1. This is possible by breaking down the canvas into 6 quadrants and then return a coordinate
* in one of the quadrants
*/
function _getCoordinateFromHash(hash: number, canvasWidth: number, canvasHeight: number): { x: number, y: number } {
  const horizontalSections = 3;
  const verticalSections = 2;

  let x = 0, y = 0;

  if(0 <= hash && hash < 0.25) {
    // place coordinates in top left quadrant
    const maxX = canvasWidth / horizontalSections;
    const maxY = canvasHeight / verticalSections;


    x = hash * maxX;
    y = hash * maxY;
  }

  return { x, y }
}

/**
 * Returns the dimensions for a shape based on a given hash. The dimension includes width, height, and
 * radius of a shape.
 */
function _getDimensionFromHash(hash: number, maxWidth: number, maxHeight: number): {width: number, height: number, radius: number} {
  // get the last three digits from the hash
  hash = parseInt(hash.toString().slice(-3));
  
  let width = hash * hash;
  let height = hash * hash;
  let radius = hash * hash;

  while(width > maxWidth) {
    width = width / 2;
  }

  while(height > maxHeight) {
    height = height / 2;
  }

  while(radius > maxWidth) {
    radius = radius / 2;
  }

  return { width, height, radius };
}

/**
 * Artist is used to create a canvas and draw shapes on it
 */
function useArtist(p5Canvas: Ref) {
  const { getHash, getRandomNumber } = useCrypto();

  const p5Instance = ref<P5>();
  
  const seed = ref<string>();
  const hash = ref<number>();
  const shapeNumber = ref<number>(0);
  const canvasWidth = ref<number>(0);
  const canvasHeight = ref<number>(0);
  const shapes = ref<Shape[]>([]);

  /**
	 * Draws a canvas using p5.js
	 */
  function drawShapes(config: ArtistConfig): void { 
    seed.value = config.seed || undefined;
    shapeNumber.value = config.shapeNumber || 5;
    hash.value = seed.value ? getHash(seed.value, true) : getRandomNumber({ absolute: true, removeDouble: true });
    
    // if p5 instance already exists, redraw the canvas
    if (p5Instance.value) {
      return p5Instance.value.redraw();
    }

    // create a new p5 instance
    p5Instance.value = new P5((p: P5) => {
      // this function is called once, in the beginning
      p.setup = () => {
        canvasWidth.value = p5Canvas.value?.offsetWidth || 400;
        canvasHeight.value = p5Canvas.value?.offsetHeight || 400;
        const canvasElement = p.createCanvas(canvasWidth.value, canvasHeight.value);

        // append canvas to parent container
        canvasElement.parent(p5Canvas.value);

        // this method ensures that `p.draw()` is only called once. (remove it to see something cool)
        p.noLoop();
      };

      // This function can be called multiple times via `p.redraw()`, `p.loop()`, etc.
      p.draw = () => {
        // clear canvas
        p.clear(0, 0, canvasWidth.value, canvasHeight.value);

        // clear shapes
        shapes.value = [];

        // number of digits from seed that will be used to generate a shape, respectively.
        const digitsPerShape = _getLastDigit(hash.value!);

        // array of seeds that will be used to generate shapes. One hash per shape to be generated.
        const shapeSeeds: string[] = _getSubSeeds(hash.value!.toString(), shapeNumber.value, digitsPerShape);

        // set canvas dimensions
        const canvas: Canvas = {
          width: canvasWidth.value,
          height: canvasHeight.value
        }

        // draw new shapes
        for(let i = 0; i < shapeSeeds.length; i++) {
          
          // get previous shape
          const prevShape: Shape | undefined = shapes.value.length > 0 ? shapes.value[i - 1] : undefined;
          
          // generate shape
          const shape = config.shapeGenerator(shapeSeeds[i], canvas, prevShape);

          // draw shape
          p.fill(shape.color);
          p.rect(shape.x, shape.y, shape.width, shape.height);

          // add shape to shapes array
          shapes.value.push(shape);
        }
      };
    });
  }

  return {
    p5Canvas,
    p5Instance,
    drawShapes
  };
}

/**
 * Pattern is used to create shapes (e.g. square, rectangle, circle, etc.)
 */
function usePattern() {
  const { getHash, getRandomNumber } = useCrypto();
  const { convertStringToColor, getRandomHexColor } = useColor();
  
  /**
	 * Returns square/rectangle shape
	 */
  function createQuadShape(seed: string, canvas: Canvas, prevShape?: Shape): Shape {
    const hash = getHash(seed || getRandomNumber() + '', true);
    const color = seed ? convertStringToColor(hash + '') : getRandomHexColor();
    
    let { x, y } = _getCoordinateFromHash(hash, canvas.width, canvas.height);
    const { width, height } = _getDimensionFromHash(hash, canvas.width, canvas.height);

    // if previous shape exists, make sure that the new shape's coordinates are not within 100 pixels of the previous shape
    if(prevShape) {
      if(prevShape.x - 100 < x && x < prevShape.x + 100) {
        x = x + 100;
      }

      if(prevShape.y - 100 < y && y < prevShape.y + 100) {
        y = y + 100;
      }
    }

    return { x, y, width, height, color };
  }

  return {
    createQuadShape
  };
}

export { useArtist, usePattern };

/**
 * This module relies heavily on seeds and hashes to generate shapes. A seed is a string that is
 * used to deterministically generate a hash. A hash is a number representation of the seed
 * and it is used, along with its digits, to deterministically generate the dimensions of a shape.
 */

import P5 from 'p5';
import { ref, type Ref } from 'vue';
import { useColor, useCrypto } from './index';

/**
 * Canvas that will be drawn on
 */
export interface Canvas {
	width: number;
	height: number;
}

/**
 * Shape that will be drawn on the canvas
 */
export interface Shape {
  seed: string;
	x: number;
	y: number;
	color: string;
}

export interface QuadShape extends Shape {
  width: number;
  height: number;
}

export interface TriangleShape extends Shape {
  width: number;
  height: number;
}

export interface CircleShape extends Shape {
  diameter: number;
}

/**
 * Function that draws a shape
 */
export interface ShapeGenerator {
  (p: P5, seed: string, canvas: Canvas, prevShape?: Shape): Shape;
}

/**
 * Configurations for the artist composable
 */
interface ArtistConfig {
  /**
   * Used to generate shapes in a deterministic way
   */
  seed?: string;
  /**
   * Number of shapes to draw
   */
  shapeNumber?: number;
  /**
   * Function that draws a shapes
   */
  shapeGenerator: ShapeGenerator;
}

/**
 * Patterns that can be used to generate shapes
 */
export type Pattern = 'quad' | 'circle' | 'triangle';

/**
 * Returns the last digit of a number. (e.g. If the number is a double, then the last digit
 * of the decimal is returned. If the last digit is 0, then the next digit to the left is 
 * returned.)
 * 
 * @param num - number to get the last digit from
 * @param digitNum - number of digits to get from the number
 */
function _getLastDigits(num: number, digitNum?: number): number {
  const numStr = num.toString();

  // if digitNum is not provided or is greater than the length of the number, then set it to 1
  if(!digitNum || (digitNum && digitNum > numStr.length)){
    digitNum = 1;
  }
  
  let lastDigits: number = parseInt(numStr[numStr.length - digitNum]);
  
  // this is not perfect, but it stops the 'loop of death' from happening which works for now
  if(lastDigits === 0) {
    lastDigits = 1;
  }

  //while(lastDigits === 0) {
  //  // get next digit to the left
  //  lastDigits = parseInt(numStr[numStr.length - digitNum + 1]);
  //}

  return lastDigits;
}

/**
* Returns a list of deterministic sub-seeds from the original seed. (e.g. if original hash is
* 0.123456789 and shapeNumber is 3, then each shape will be generated by using 3 digits from 
* the original hash and starting from left to right such that: `shapeHashes = [123, 456, 789]` )
* 
* @param seed - original seed
* @param subSeedNum - number of sub-seeds to generate
* @param digitsPerShape - number of digits to use from the original seed to generate each sub-seed
*/
function _getSubSeeds(seed: string, subSeedNum: number, digitsPerShape: number): string[] {
  
  const seeds: string[] = [];
          
  let index = 0;

  while(seeds.length < subSeedNum) {
    let extraction: string;
    
    // index has reached the end of the seed, so start over
    // and increment the `digitsPerShape` to get more randomness
    if(index >= seed.length) {
      index = 0;
      digitsPerShape ++;
    }

    // index is about to go out of bounds, so break the 
    // seed-to-extact into two parts
    if(index + digitsPerShape > seed.length) {
      const diff = (index + digitsPerShape) - seed.length;
      const first = seed.slice(index, seed.length);
      const second = seed.slice(0, diff);

      extraction = `${first}${second}`;

      index = diff;
      digitsPerShape ++;
    }

    else {
      extraction = seed.slice(index, index + digitsPerShape);
      index += digitsPerShape;
    }

    seeds.push(extraction)
  }

  return seeds;
}

/**
 * Artist is used to create a canvas and draw shapes on it
 */
function useArtist(p5Canvas: Ref) {
  const { getHash, getRandomNumber } = useCrypto();

  const p5Instance = ref<P5>();
  
  const seed = ref<string>();
  const hash = ref<number>();
  const shapeNumber = ref<number>(0);
  const canvasWidth = ref<number>(0);
  const canvasHeight = ref<number>(0);
  const shapes = ref<Shape[]>([]);

  /**
	 * Draws a canvas using p5.js
	 */
  function drawShapes(config: ArtistConfig): void { 
    // set seed
    seed.value = config.seed || undefined;

    // set hash. If seed is not provided, then generate a random hash
    hash.value = seed.value ? getHash(seed.value, true) : getRandomNumber({ absolute: true, removeDouble: true });

    // set shape number. If not provided, then use the last digit of the hash
    shapeNumber.value = config.shapeNumber || Math.ceil((_getLastDigits(hash.value) / 2));

    /**
     * Removes the p5 instance from the DOM if it exists to allow for
     * a new pattern `ShapeGenerator` to be configured instead of using
     * the `p5Instance.value.remove()` method which re-uses the previous
     * pattern's `ShapeGenerator` function.
     */
    if (p5Instance.value) {
      p5Instance.value.remove();
    }

    // create a new p5 instance
    p5Instance.value = new P5((p: P5) => {
      // this function is called once, in the beginning
      p.setup = () => {
        canvasWidth.value = p5Canvas.value?.offsetWidth || 400;
        canvasHeight.value = p5Canvas.value?.offsetHeight || 400;
        const canvasElement = p.createCanvas(canvasWidth.value, canvasHeight.value);

        // append canvas to parent container
        canvasElement.parent(p5Canvas.value);

        // this method ensures that `p.draw()` is only called once. (remove it to see something cool)
        p.noLoop();
      };

      // This function can be called multiple times via `p.redraw()`, `p.loop()`, etc.
      p.draw = () => {
        // clear canvas
        p.clear(0, 0, canvasWidth.value, canvasHeight.value);

        // clear shapes
        shapes.value = [];

        // number of digits from seed that will be used to generate a shape, respectively.
        const digitsPerShape = _getLastDigits(hash.value!);

        // array of seeds that will be used to generate shapes. One hash per shape to be generated.
        const shapeSeeds: string[] = _getSubSeeds(hash.value!.toString(), shapeNumber.value, digitsPerShape);
        
        // draw new shapes
        for(let i = 0; i < shapeSeeds.length; i++) {
          // set canvas dimensions
          const canvas: Canvas = {
            width: canvasWidth.value,
            height: canvasHeight.value
          }
          
          // get previous shape
          const prevShape: Shape | undefined = shapes.value.length > 0 ? shapes.value[i - 1] : undefined;
          
          // draw shape
          const shape = config.shapeGenerator(p, shapeSeeds[i], canvas, prevShape);

          // store shape
          shapes.value.push(shape);
        }
      };
    });
  }

  return {
    p5Canvas,
    p5Instance,
    drawShapes
  };
}

/**
 * Pattern is used to create shapes (e.g. square, rectangle, circle, etc.)
 */
function usePattern() {
  const { getHash, getRandomNumber } = useCrypto();
  const { convertStringToColor, getRandomHexColor } = useColor();

  /**
   * List of patterns that can be used to generate shapes
   */
  const patterns: Pattern[] = [ 'quad', 'circle', 'triangle' ]

  /**
   * Returns a coordinate that is positive and less than 1 based on a hash that is positive and less 
   * than 1. This is possible by breaking down the canvas into a 3x3 grid and returning a coordinate
   * within this space.
   * 
   * note: this function never returns a coordinate that is in the last column or row of the grid to 
   * avoid shapes being drawn outside of the canvas
   */
  function _getCoordinateFromHash(hash: number, maxHorizontal: number, maxVertical: number, useWholeCanvase?: boolean): { x: number, y: number } {
    let x = 0, y = 0;
    
    /**
     * sectionWidth and sectionHeight are used to break down the canvas into 6 quadrants
     * 
     * note: if `useWholeCanvase` is false, then the values are decided by cutting the canvas 
     * in half vertically and horizontally to avoid shapes being drawn outside of the canvas
     */
    const sectionWidth = useWholeCanvase ? maxHorizontal / 3 : (maxHorizontal / 2) / 3;
    const sectionHeight = useWholeCanvase ? maxVertical / 3 : (maxHorizontal / 2) / 3;
    
    // indicators are used to determine which quadrant the shape will be placed in
    const xIndicator = _getLastDigits(hash + hash);
    const yIndicator = _getLastDigits(hash * hash);

    /**
     * determine which quadrant the shape will be placed in. 0-3 is 
     * the left half of the canvas, 3-6 is the center, and 6-9 is
     * the right half
     * 
     * note: math isn't thought out well here. It just needs to be reproducible
     */
    if(0 <= xIndicator && xIndicator <= 3) {
      x = sectionWidth - (sectionWidth - xIndicator);
    } else if(3 < xIndicator && xIndicator <= 6) {
      x = (sectionWidth * 2) - xIndicator;
    } else {
      x = (sectionWidth * 3) - xIndicator;
    }

    /**
     * determine which quadrant the shape will be placed in. 0-3 is
     * the top half of the canvas, 3-6 is the center, and 6-9 is
     * the bottom half
     * 
     * note: math isn't thought out well here. It just needs to be reproducible
     */
    if(0 <= yIndicator && yIndicator <= 3) {
      y = sectionHeight - (sectionHeight - yIndicator);
    } else if(3 < yIndicator && yIndicator <= 6) {
      y = (sectionHeight * 2) - yIndicator;
    } else {
      y = (sectionHeight * 3) - yIndicator;
    }

    return { x, y }
  }

  /**
   * Returns the dimensions for a shape based on a given hash. The dimension includes width, height, and
   * radius of a shape.
   */
  function _getDimensionFromHash(hash: number, maxWidth: number, maxHeight: number): {width: number, height: number, diameter: number} {
  // get the last three digits from the hash
    hash = parseInt(hash.toString().slice(-3));
  
    let width = hash * hash;
    let height = hash * hash;
    let diameter = hash;

    while(width > maxWidth) {
      width = width / 2;
    }

    while(height > maxHeight) {
      height = height / 2;
    }

    while(diameter > maxWidth) {
      diameter = diameter / 2;
    }

    return { width, height, diameter };
  }

  /**
	 * Returns square/rectangle shape
	 */
  function createQuadShape(p: P5, seed: string, canvas: Canvas, prevShape?: Shape): QuadShape {
    const hash = getHash(seed || getRandomNumber() + '', true);
    const color = seed ? convertStringToColor(hash + '') : getRandomHexColor();
    
    let { x, y } = _getCoordinateFromHash(hash, canvas.width, canvas.height);
    const { width, height } = _getDimensionFromHash(hash, canvas.width, canvas.height);

    // if previous shape exists, make sure that the new shape's coordinates are not within 100 pixels of the previous shape
    if(prevShape) {
      if(prevShape.x - 100 < x && x < prevShape.x + 100) {
        x = x + 100;
      }

      if(prevShape.y - 100 < y && y < prevShape.y + 100) {
        y = y + 100;
      }
    }

    // define shape
    const shape: QuadShape = {
      seed,
      x,
      y,
      width,
      height,
      color
    };

    // draw shape
    p.fill(shape.color);
    p.rect(shape.x, shape.y, shape.width, shape.height);

    return shape;
  }

  /**
	 * Returns circle shape
	 */
  function createCircleShape(p: P5, seed: string, canvas: Canvas, prevShape?: Shape): CircleShape {
    const hash = getHash(seed || getRandomNumber() + '', true);
    const color = seed ? convertStringToColor(hash + '') : getRandomHexColor();
    
    let { x, y } = _getCoordinateFromHash(hash, canvas.width, canvas.height, false);
    const { diameter } = _getDimensionFromHash(hash, canvas.width, canvas.height);

    // if previous shape exists, make sure that the new shape's coordinates are not within 100 pixels of the previous shape
    if(prevShape) {
      if(prevShape.x - 100 < x && x < prevShape.x + 100) {
        x = x + 100;
      }

      if(prevShape.y - 100 < y && y < prevShape.y + 100) {
        y = y + 100;
      }
    }

    // define shape
    const shape: CircleShape = {
      seed,
      x,
      y,
      diameter,
      color
    };

    // draw shape
    p.fill(shape.color);
    p.circle(shape.x, shape.y, shape.diameter * 2);

    return shape;
  }

  /**
	 * Returns triangle shape
	 */
  function createTriangleShape(p: P5, seed: string, canvas: Canvas, prevShape?: Shape): TriangleShape {
    const hash = getHash(seed || getRandomNumber() + '', true);
    const color = seed ? convertStringToColor(hash + '') : getRandomHexColor();
    
    let { x, y } = _getCoordinateFromHash(hash, canvas.width, canvas.height, false);
    const { width, height } = _getDimensionFromHash(hash, canvas.width, canvas.height);

    // if previous shape exists, make sure that the new shape's coordinates are not within 100 pixels of the previous shape
    if(prevShape) {
      if(prevShape.x - 100 < x && x < prevShape.x + 100) {
        x = x + 100;
      }

      if(prevShape.y - 100 < y && y < prevShape.y + 100) {
        y = y + 100;
      }
    }

    // define shape
    const shape: TriangleShape = {
      seed,
      x,
      y,
      width,
      height,
      color
    };

    // draw shape
    p.fill(shape.color);
    p.triangle(
      shape.x,
      shape.y,
      shape.x + shape.width,
      shape.y,
      shape.x + shape.width,
      shape.y + shape.height
    );

    return shape;
  }

  return {
    patterns,
    createQuadShape,
    createCircleShape,
    createTriangleShape
  };
}

export { useArtist, usePattern };
